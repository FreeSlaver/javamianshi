---
layout: page
breadcrumb: true
title: 预约箱格请求排队
category: java
categoryStr: java
tags: 
keywords: 
description: 
---


在重构E栈项目的时候有一个比较麻烦的需求，就是预约箱格请求排队，描述如下：

用户预约一种箱型，比如BIG的箱格，但是目前没有可用的，但是这个箱型是可以排队的。

排队只能排当天的，并且每天有不定的时间段，比如：7点到9点，9点到11点，14到17点，20到22点等。

这个排队时间段是可以任意配置的，但是是整点到整点。每个箱型的每个时间段的排队人数是有上限的。


### 技术上要实现：

1.释放一个空箱格，分配给最新排队的请求。

2.分配箱格给请求后，回调排队请求发起方（比如APP），告知排队成功，获取到箱格是xx

3.回调失败，需要将请求重新排队，释放掉箱格。

4.在一个时间段结束后，还是没排上箱格，需要踢除请求，告知请求发起方（比如APP）排队失败。

本来项目主要都是用的redis来处理箱格之类的，刚开始使用的redis的keyspace notification。

###　需要解决几个问题：

1.请求顺序排队

2.请求分不同的箱型

3.请求分不同的时间段

4.回调失败，进行重排

5.排队时间段结束，回调告知失败。

刚开始使用前缀+终端号（sn）+时间段+箱型（boxType） 为key，然后请求放到redis list中。我们知道redis list就是个链表，可以排序，获取最先的请求，删除请求，重排队都很方便。但是就是这个时间段过期了，这个list失效了，list里面所有的请求都需要回到告知APP，比较麻烦。这里就用到了redis的keyspace notification来监听key值的变化或者事件。

总的上功能是能够完成了。但是那个时间段很不好弄，刚开始是写死的，后面想写到配置文件中也不太好弄。主要是一个请求过来了，你不太好判定它是那个时间段。

后面使用了直接存DB的方案替代掉了。发现非常的方便。

排序，直接使用order by，删除请求就是该下状态，重新排队，就是将原来的状态改掉，生成一条新的记录，使用自增ID。

然后一个可用空箱箱型为BIG，释放了，那么久分配给排队开始时间小于当前时间，结束时间大于当前时间的请求就好了。

排队时间段逾期，使用5分钟定时扫描数据库，看排队结束时间是否大于当前时间，大于，就是排队过期失效了，然后回调通知APP。




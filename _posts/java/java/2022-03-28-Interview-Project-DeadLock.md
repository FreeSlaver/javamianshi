---
layout: page
breadcrumb: true
title: Java项目常见高频面试题-死锁
category: java
categoryStr: java
tags:
keywords:
description:
---

问：你们项目中有没遇到死锁啊？哪些场景下出现的  
答：我现在还有印象的死锁情况是： 
第一个：在中级电商e栈项目中，用Redis分布式锁锁定箱格的时候； 
当时是发现随着系统运行越来越多的箱格预分配之后没有释放，导致本来还有箱格，但是快递员无法放快递，  
然后查找问题，发现是哨兵模式下master上设置了锁之后，还没来得及同步，或者同步数据量太大，slaver一直没通过成功，然后master又挂掉的情况。  
第二个：Kafka集群consumer端消费死锁  
这个死锁是kafka在0.8版本时候的bug，就是broker上没有最新的消息后，consuer会进入死循环等待。  
第三个：MySQL数据库死锁  
就是在高并发情况下，下订单扣减库存，比如说用户1买了B和C两件商品，去扣减库存，然后用户2买了C和B两种商品也去扣减库存的时候，商品顺序反了，这时就发生死锁了。 因为用户1和用户2这两个线程循环等待对方持有的锁资源。
还有一种情况是商家在后台提交修改某几个商品的库存，然后同时又有用户下单或者退货，导致库存改变，这时会死锁。 
还有一种情况是：相同表记录行锁冲突，之前遇到两个定时任务job在执行数据批量更新时，    
jobA处理的的id列表为 [1,2,3,4] ，而job处理的id列表为 [8,9,10,4,2] ，这样就造成了死锁。  

问：那你们怎么解决的？  
第一个redis的死锁问题，使用的Redisson，会设置过期时间，并且自动续约机制，如果发生了死锁，即master挂掉还没同步到slaver，redissson本地记录有逾期时间，会判断。  
第二个是将Kafka的集群版本进行直接升级，这个bug在官方的issues里面有。  
第三个MySQL的死锁，解决方法是：1.在扣减多件商品库存时，先将商品进行排序，让他们安照顺序执行。
2.尽量缩减事务的范围，粒度级别，这样大大减小发生死锁的概率；
3.将默认的Reapeatable Read隔离级别改成Read Committed，这样可以避免间隙锁造成的死锁，但是可能会造成幻读。  
然后MySQL它默认有那个deadLock_detection机制会自动探测死锁然后进行回滚，一般是占用行最小的事务，  
或者有那个trasaction_timeout超时时间设置得小点，会超时后释放回滚。4.将需要的资源一次性锁定，这样不会交叉持有，但是会造成更多的线程阻塞等待。 



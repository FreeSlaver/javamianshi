---
layout: page
breadcrumb: true
title: 关于JDK几种锁的名词解释
category: java
categoryStr: 并发
tags: 
keywords: 
description: 
---

摘录自《深入理解JAVA虚拟机》。



JDK1.5到1.6对锁进行了大量优化，适应性自旋（Adaptive Spinning），锁清除（Lock Elimination），锁粗化（Lock Coarsening），轻量级锁（Lightweight Locking）和偏向锁（Biased Locking）等，都是为了高效的共享数据。

### 自旋锁与自适应锁

互斥同步对性能最大的影响是阻塞的实现，挂起线程和回复线程的操作都需要转入内核态中完成，也就是造成很大的用户态和内核态切换的开销。

许多应用上，共享数据的锁定只会持续很短的一段时间，为了这段时间挂起和回复线程不值得。这种情况下，我们可以让后面请求锁的线程稍等一下，但是不放弃处理器的执行时间（也就是分配给它的CPU时间切片），看看尺有锁的线程是否很快就会释放锁。线程等待的实现就是通过一个忙循环，也就是自旋，这项技术叫自旋锁。

如果自旋超过了限定的次数依然没有成功获得锁，那么使用传统方式阻塞挂起。默认次数是10次。

自适应的自旋锁，，意味着自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态决定。就是看上一次自旋拿到锁的情况。

### 锁消除

锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定一句来源于逃逸分析的数据支持。如果判断在一段代码中，对上的所有数据都不会逃逸出去，从而被其他线程访问到，那就可以把他们当做栈上数据对的，认为他们是线程私有的，同步加锁自然无须进行。

### 锁粗化

写代码，总是推荐同步块的作用范围越小越好，只在共享数据的时机作用域中才进行同步。但是如果一系列的操作对同一个对象反复加锁和解锁，但是却没有线程竞争，频繁的进行互斥同步操作会造成性能损耗。

虚拟机会将这一串的操作的加锁同步范围扩大到真个操作序列的外部，这就是锁粗化。

### 轻量级锁（重点）

轻量级是相对于使用操作系统互斥量来实现的传统锁而言的。HotSpot虚拟机的对象头（Object Header）分两部分，第一部分用于存储对象自身的运行时数据，如哈希码，GC分代年龄等。长度对应操作系统为32bit和64bit，官方称为“Mark Word”，他是实现轻量级锁和偏向锁的关键。

另外一部分用于存储只想方法去对象类型数据的指针，如果是数组，会额外存数组长度。

![1]( /img/life/Locks-Noun_1.jpg )


原理：在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志为“01”），虚拟机首先将当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（会加Displaced前缀），这时候线程栈帧和对象头如图所示。

![2]( /img/life/Locks-Noun_2.jpg )


然后虚拟将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针。如果成功，这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位（最后2bit）将变为“00”，即表示此对象处于轻量级锁定状态，这个时候如图所示：

![3]( /img/life/Locks-Noun_3.jpg )

如果更新操作失败，虚拟机首先检查对象的Mark Word是否指向当前线程的栈帧，如果当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则，说明这个锁对象已经被其他线程抢占了。

如果有2条以上的线程争用同一个锁，那轻量级锁就不再有效，需要膨胀为重量级锁，标志位的状态值变为“10”，Mark Word中存储的就是只想重量级锁的指正，后面等待锁的进入阻塞。

解锁过程也是通过CAS，如果对象的Mark Word任然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来，如果替换成功，整个同步过程完成。如果替换失败，说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。


为了能直观的理解lock，unlock与mark word之间的联系，我画了一张流程图：

![4]( /img/life/Locks-Noun_4.jpg )


### 偏向锁

它的目的是消除数据在无竞争情况下的同步源于，进一步提高程序的运行性能。偏的意思是这个锁会偏向第一个获得它的线程，如果在金袭来的执行过程中，该所没有被其他的线程获取，则持有偏向锁的线程将永远不需要进行同步。

原理： 当锁对象第一次被线程获取的时候，虚拟机将对象投中的标志位设置为“01"，即偏向模式。同事使用CAS操作把获得到这个锁的线程ID记录在对象的Mark Word中，如果CAS成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不在进行任何同步操作。

当另外一个线程尝试获取这个锁时，偏向模式结束。根据锁对象是否被锁定的状态，撤销偏向后回复到未锁定或者轻量级锁定（标志位"00"），后续操作通轻量级锁。



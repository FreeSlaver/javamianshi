---
layout: page
breadcrumb: true
title: 本地缓存 分布式缓存 数据库db的数据一致性
category: redis
categoryStr: redis
tags: [redis]
keywords:
description:
---


**有个面试题：问：怎么保证本地缓存，分布式缓存，数据库db的数据一致性？**  
答：应该还是要遵循缓存的定义和cache aside pattern模型。
####查询
先读本地缓存，有返回，没有，读分布式缓存，有返回，并且设置到本地缓存。  
还是没有，查询数据库db，然后将数据缓存到本地缓存和分布式缓存中。本地缓存一般用ConcurrentHashMap或者Guava    
### 修改
直接修改db中的数据，然后放缓存到本地缓存和分布式缓存中，如果放分布式失败，重试3次，在失败丢队列重试。

**问：这里按照缓存的定义，不应该只用存到分布式缓存中，然后本地缓存下次由分布式缓存啦取么？** 
答：因为直接存放到本地缓存中的开销极小，并且几乎不可能出错。  

**问：那放到本地缓存时，什么情况会出错？**  
同时有另外的一个线程遍历，就ConcurrentModifiedException；或者内存不够。  

**1.如何保证请求过来命中本地缓存？现在都是分布式微服务多实例的，比如有多个订单微服务实例，怎么做？**  
答：因为订单都是和用户和商家强关联的，所以同一个用户或者商家的一次session会连接到固定的一个实例中，这次session中缓存一直有效。  
为避免多个实例上面，本地缓存不一致，用户登出时，需要删除掉用户相关的本地缓存  
但是如果用户反复登陆，本地缓存就会失效，如果这种情况下也要保证的话，就用一致性hash将客户每次都hash到一个固定的实例上，  
其实如果本地缓存没有命中，可以从分布式缓存中取，问题不大。如果非要保证性能的话，就用上面的方案。  

**2.如果修改了db中数据，怎么做？保证所有缓存数据一致性？将缓存都清除的话，如果失败了？**
修改db之后，直接删除掉本地缓存和分布式缓存，删除本地缓存几乎不会失败，有可能失败的就删除分布式缓存。
会将这个请求丢到消息队列进行重试删除。

**3.如果不删除，就是改了后必须放到缓存中，怎么做？如果放的时候失败了？**
放本地缓存这一步几乎不会出错，就是操作本地的JVM内存，ConcurrentHashMap或者Guava。  
放分布式缓存失败的话，本地重试3次，再失败会丢到消息队列中进行重试，  

**问：如果有2次修改，丢消息队列的数据串了，或者A修改失败丢队列，B修改成功了，然后MQ重试，这数据不就乱了？**  
串的情况，你可以让他必须排队处理。**分布式缓存的数据带个version字段，每次会加1，B修改的version会比MQ大，直接放弃。**  

**4.你们应用在电商的哪些场景中？或者订单模块的？**
就是用户的最近的10笔订单，会缓存到起来。  

其实本质问题是个3级缓存设计。  

**比较错误的做法：**
修改db数据后，放缓存到分布式缓存，事务失败，使用MQ反查
就是修改db之后会向消息队列中发条消息，然后消费了之后，会将修改后数据和本地缓存，分布式缓存中数据进行比较，  
发现错误的，会修改掉。  
但如果又立刻修改了db数据，这样你上次修改后的数据和缓存中的都不一样了，这时候你反查应用会改回去？  


还有一种方案是使用redis的pubsub机制，然后每个为服务实例订阅  
这种有个坑是pusub机制不保证一定可达，导致本地缓存读取到错误数据。  

**注意点：**
缓存的过期时间设置  
本地缓存一般设置在一个大概session会话的时间，分布式缓存中设置的为3倍的session时间。  









